import requests
import random
import base64
import json
import logging
import os 
import io
import shutil
from datetime import datetime

# Set up logging
logging.basicConfig(filename="pokemon_cards_log.log", level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")

def read_chosen_prompt():
    with open("chosen_prompt.txt", "r", encoding='utf-8') as f:  # Specify UTF-8 encoding here
        chosen_prompt = f.read().strip()
        logging.info(f"Chosen prompt: {chosen_prompt}")
        return chosen_prompt

# Function to select a random image and move it after use
def select_and_move_image(source_dir, used_dir):
    files = [file for file in os.listdir(source_dir) if file.endswith(('.png', '.jpg', '.jpeg'))]
    if not files:
        logging.error("No images found in the directory.")
        return None
    selected_image = random.choice(files)
    image_path = os.path.join(source_dir, selected_image)
    used_image_path = os.path.join(used_dir, selected_image)
    # Move the image after using
    shutil.move(image_path, used_image_path)
    return used_image_path

# Define image directories
source_directory = "assets"
used_directory = "used"

# Select a random image and move it after use
image_path = select_and_move_image(source_directory, used_directory)
if not image_path:
    exit(1)  # Exit if no image is found

# Read selected image file from disk
with open(image_path, "rb") as image_file:
    encoded_image = base64.b64encode(image_file.read()).decode('utf-8')

# Define the API URL
api_url = "http://127.0.0.1:7860/sdapi/v1/img2img"

# Define the payload for animate_diff_args
animate_diff_args = {
    "model": "mm_sd_v15_v2.ckpt",
    "format": ["MP4", "PNG"],
    "enable": True,
    "video_length": 225,
    "fps": 30,
    "loop_number": 0,
    "closed_loop": "A",
    "batch_size": 16,
    "stride": 1,
    "overlap": -1,
    "interp": "NO",
    "interp_x": 10,
    "latent_power": 0.6,               # Latent power 
    "last_frame": [encoded_image],     # Optional last frame
    "latent_power_last": 0.6 # Optional latent power for last frame
}


# Read the prompt from the file generated by the first script
chosen_prompt = read_chosen_prompt()

# Define the JSON payload
json_payload = {
    "init_images": [encoded_image],
    "prompt": chosen_prompt,
    "negative_prompt": "Compression artifacts, nudity, nsfw, Bad art, worst quality, low quality, plastic, fake, bad limbs, conjoined, featureless, bad features, incorrect objects, watermark, piercings, logo, watermark, blurry, grainy",
    "batch_size": 1,
    "sampler_name": "DDIM",
    "steps": 12,
    "cfg_scale": 7,
    "denoising_strength": 0.7,
    "save_images": True,
    "width": 490,
    "height": 684,
    "alwayson_scripts": {
        "AnimateDiff": {"args": [animate_diff_args]}
    }
}

# Define headers
headers = {
    "Content-Type": "application/json"
}

# Call the API
response = requests.post(api_url, headers=headers, json=json_payload)

# Check for successful response
if response.status_code == 200:
    r = response.json()
    # Assuming 'images' key contains a list of base64 encoded strings
    if 'images' in r and r['images']:
        base64_data = r['images'][0]
        
        # Decode base64 (assuming the data is direct base64 of MP4, no additional splitting needed)
        mp4_data = base64.b64decode(base64_data)

        # Write the MP4 data to a file
        with open('lowscale.mp4', 'wb') as file:
            file.write(mp4_data)
        print("MP4 file saved as 'low_scale.mp4'.")
    else:
        print("No image data found in the response.")
else:
    print(f"API call failed. Status Code: {response.status_code}, Response: {response.text}")


# Debugging and Logging
if response.status_code == 200:
    logging.info(f"API call successful. Status Code: {response.status_code}")
    response_json = response.json()

    # Write JSON response to a file
    with open("api_response.txt", "w") as file:
        json.dump(response_json, file, indent=4)

else:
    logging.error(f"API call failed. Status Code: {response.status_code}, Response: {response.text}")
    response_json = {}
