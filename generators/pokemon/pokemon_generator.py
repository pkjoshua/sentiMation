from PIL import Image
import requests
import random
import base64
import json
import logging
import os
import shutil
from datetime import datetime

# Set up logging
logging.basicConfig(filename="pokemon_log.log", level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")

def read_chosen_prompt():
    with open("chosen_prompt.txt", "r", encoding='utf-8') as f:
        chosen_prompt = f.read().strip()
        logging.info(f"Chosen prompt: {chosen_prompt}")
        return chosen_prompt

def resize_image_to_even_dimensions(image):
    width, height = image.size
    if width % 2 != 0:
        width -= 1
    if height % 2 != 0:
        height -= 1
    return image.resize((width, height), Image.Resampling.LANCZOS)

def create_mask(image_path):
    with Image.open(image_path) as img:
        img = img.convert("RGBA")
        new_data = []
        for item in img.getdata():
            if item[3] == 0:  # Transparent pixels
                new_data.append((0, 0, 0, 255))  # Black
            else:
                new_data.append((255, 255, 255, 255))  # White
        img.putdata(new_data)
        img = img.convert("RGB")
        img = resize_image_to_even_dimensions(img)

        # Save the mask as 'current_mask.png' in the same directory as the script
        current_mask_path = os.path.join(os.path.dirname(__file__), "current_mask.png")
        img.save(current_mask_path)

        return img
def process_image(image_path, used_dir):
    # Resize original image
    with Image.open(image_path) as img:
        img = resize_image_to_even_dimensions(img)

        # Save the resized image in the used directory
        resized_image_path = os.path.join(used_dir, os.path.basename(image_path))
        img.save(resized_image_path)

        # Save another copy as 'current_pokemon.png' in the script's current directory
        current_pokemon_path = os.path.join(os.path.dirname(__file__), "current_pokemon.png")
        img.save(current_pokemon_path)

    # Create mask and save as 'current_mask.png'
    mask = create_mask(resized_image_path)

    # Save another copy of the mask in the used directory
    mask_path = os.path.join(used_dir, f"mask_{os.path.basename(image_path)}")
    mask.save(mask_path)

    return resized_image_path, mask_path

def select_and_move_image(source_dir, used_dir):
    files = [file for file in os.listdir(source_dir) if file.endswith(('.png', '.jpg', '.jpeg'))]
    if not files:
        logging.error("No images found in the directory.")
        return None, None
    selected_image = random.choice(files)
    image_path = os.path.join(source_dir, selected_image)

    # Write the selected Pokemon name to pokemon_selected.txt
    pokemon_name = os.path.splitext(selected_image)[0]
    with open("pokemon_selected.txt", "w") as file:
        file.write(pokemon_name)

    # Process the image and its mask
    resized_image_path, mask_path = process_image(image_path, used_dir)

    os.remove(image_path)

    return resized_image_path, mask_path

# Define image directories
source_directory = "assets"
used_directory = "used"

# Select a random image, create its mask, and move the image after use
image_path, mask_path = select_and_move_image(source_directory, used_directory)
if not image_path or not mask_path:
    exit(1)

# Read and encode image and mask
with open(image_path, "rb") as image_file:
    encoded_image = base64.b64encode(image_file.read()).decode('utf-8')

with open(mask_path, "rb") as mask_file:
    mask_image = base64.b64encode(mask_file.read()).decode('utf-8')

# Read the prompt from the file generated by the first script
chosen_prompt = read_chosen_prompt()

# Define the payload for animate_diff_args
animate_diff_args = {
    "model": "mm_sd_v15_v2.ckpt",
    "format": ["MP4", "PNG"],
    "enable": True,
    "video_length": 240,
    "fps": 30,
    "loop_number": 0,
    "closed_loop": "R-P",
    "batch_size": 16,
    "stride": 1,
    "overlap": -1,
    "interp": "NO",
    "interp_x": 10,
    "latent_power": 1.5, 
    "latent_scale": 32,                   
    "latent_power_last": 4,
    "last_frame": None,
    "latent_scale_last": 32
}

# Define the API URL
api_url = "http://127.0.0.1:7860/sdapi/v1/img2img"

# Define the JSON payload
json_payload = {
    "init_images": [encoded_image],
    "mask": mask_image,
    "inpainting_fill": 0,
    "mask_blur": 0,
    "inpaint_full_res": True,
    "inpaint_full_res_padding": 32,
    "guidance_scale": 7.5,
    "prompt": chosen_prompt,
    "negative_prompt": "Compression artifacts, nudity, nsfw, Bad art, worst quality, low quality, plastic, fake, bad limbs, conjoined, featureless, bad features, incorrect objects, watermark, piercings, logo, watermark, blurry, grainy",
    "batch_size": 1,
    "sampler_name": "DDIM",
    "steps": 12,
    "cfg_scale": 7,
    "denoising_strength": 0.8,
    "save_images": True,
    "width": 474,
    "height": 474,
    "alwayson_scripts": {
        "AnimateDiff": {"args": [animate_diff_args]}
    }
}

# Define headers
headers = {
    "Content-Type": "application/json"
}

# Call the API
response = requests.post(api_url, headers=headers, json=json_payload)

# Check for successful response and handle the response
if response.status_code == 200:
    r = response.json()
    if 'images' in r and r['images']:
        base64_data = r['images'][0]
        mp4_data = base64.b64decode(base64_data)
        with open('lowscale.mp4', 'wb') as file:
            file.write(mp4_data)
        print("MP4 file saved as 'low_scale.mp4'.")
    else:
        print("No image data found in the response.")
else:
    print(f"API call failed. Status Code: {response.status_code}, Response: {response.text}")

# Logging
if response.status_code == 200:
    logging.info(f"API call successful. Status Code: {response.status_code}")
    response_json = response.json()
    with open("api_response.txt", "w") as file:
        json.dump(response_json, file, indent=4)
else:
    logging.error(f"API call failed. Status Code: {response.status_code}, Response: {response.text}")